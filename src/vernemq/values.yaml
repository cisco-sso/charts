rbac:
  create: true

serviceAccount:
  create: true
  name:

repicaCount: 1  # Desired quantity of pods.

podDisruptionBudget: |
  maxUnavailable: 1  # Limits how many pods may be unavailable due to voluntary disruptions.

terminationGracePeriodSeconds: 1  # Duration in seconds a pod needs to terminate gracefully.

## ref: http://blog.kubernetes.io/2017/09/kubernetes-statefulsets-daemonsets.html
updateStrategy: |
  type: RollingUpdate
  rollingUpdate:
    maxSurge: 1
    maxUnavailable: 1

image:
  repository: erlio/docker-vernemq  # Container image.
  tag: 1.5.0  # Container image tag.
  pullPolicy: IfNotPresent  # Container image pull criteria.

service:
  type: ClusterIP  # Publishes the service on a cluster-internal IP.
  annotations: {}  # Arbitrary non-identifying metadata for service.
  ports: 
  
    ## MQTT
    mqtt:
      enabled: true
      port: 1883
      targetPort: mqtt
      protocol: TCP
  
    ## MQTT WebSockets
    mqttws:
      enabled: true
      port: 8080
      targetPort: mqttws
      protocol: TCP

    ## MQTT SSL
    mqttssl:
      enabled: false
      port: 8883
      targetPort: mqttssl
      protocol: TCP

ports:

  ## MQTT
  mqtt:
    containerPort: 1883
    protocol: TCP

  ## Erlang Port Mapper Daemon (EPMD)
  epmd:
    containerPort: 4369
    protocol: TCP

  ## MQTT WebSockets
  mqttws:
    containerPort: 8080
    protocol: TCP

  ## MQTT SSL
  mqttssl:
    containerPort: 8883
    protocol: TCP

  ## Prometheus Metrics
  metrics:
    containerPort: 8888
    protocol: TCP

  ## Distributed Erlang Port 0
  erlang0:
    containerPort: 9100
    protocol: TCP

  ## Distributed Erlang Port 1
  erlang1:
    containerPort: 9101
    protocol: TCP

  ## Distributed Erlang Port 2
  erlang2:
    containerPort: 9102
    protocol: TCP

  ## Distributed Erlang Port 3
  erlang3:
    containerPort: 9103
    protocol: TCP

  ## Distributed Erlang Port 4
  erlang4:
    containerPort: 9104
    protocol: TCP

  ## Distributed Erlang Port 5
  erlang5:
    containerPort: 9105
    protocol: TCP

  ## Distributed Erlang Port 6
  erlang6:
    containerPort: 9106
    protocol: TCP

  ## Distributed Erlang Port 7
  erlang7:
    containerPort: 9107
    protocol: TCP

  ## Distributed Erlang Port 8
  erlang8:
    containerPort: 9108
    protocol: TCP

  ## Distributed Erlang Port 9
  erlang9:
    containerPort: 9109
    protocol: TCP

  ## VerneMQ Message Distribution
  vernemq:
    containerPort: 44053
    protocol: TCP

## TODO: PoC of Ingress for MQTT over secure websocket.
##
## Requires WebSocket support at both ingress controller AND its LoadBalancer.
##
## refs:
## - https://kubernetes.github.io/ingress-nginx/user-guide/miscellaneous/#websockets
## - https://medium.com/ww-engineering/k8s-ws-aws-elb-nlb-5a23834d4f14
ingress:
  enabled: false
  annotations: {}
    # kubernetes.io/ingress.class: nginx-ws
    # kubernetes.io/tls-acme: "true"
  labels: {}
  path: /
  hosts:
    - vernemq.cluster.local
  tls: []
  #  - secretName: vernemq-tls
  #    hosts:
  #      - vernemq.cluster.local

resources: {}  # Optionally specify how much CPU and memory (RAM) each container needs.
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #  cpu: 100m
  #  memory: 128Mi
  # requests:
  #  cpu: 100m
  #  memory: 128Mi
  ## TODO: Set resource limits example based on actual usage.

nodeSelector: {}  # Node label-values required to run pods.

tolerations: []  # Node taint overrides for pods.

affinity: {}  # Criteria by which pod label-values influence scheduling for pods.
  # podAntiAffinity:
  #   requiredDuringSchedulingIgnoredDuringExecution:
  #     - topologyKey: "kubernetes.io/hostname"
  #       labelSelector:
  #         matchLabels:
  #           release: vernemq

podAnnotations: {}  # Arbitrary non-identifying metadata for pods.
  # prometheus.io/scrape: "true"
  # prometheus.io/port: "8888"

podLabels: {}  # Key/value pairs that are attached to pods.

livenessProbe:
  tcpSocket:
    port: mqttws
  initialDelaySeconds: 20
  # periodSeconds: 30
  # timeoutSeconds: 30
  # failureThreshold: 6
  # successThreshold: 1

readinessProbe:
  tcpSocket:
    port: mqttws
  initialDelaySeconds: 20
  # periodSeconds: 30
  # timeoutSeconds: 30
  # failureThreshold: 6
  # successThreshold: 1

securityContext: {}
  # fsGroup: 1000
  # runAsUser: 1000

persistence:
  enabled: true
  ## data Persistent Volume Storage Class
  ## If defined, storageClassName: <storageClass>
  ## If set to "-", storageClassName: "", which disables dynamic provisioning
  ## If undefined (the default) or set to null, no storageClassName spec is
  ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
  ##   GKE, AWS & OpenStack)
  ##
  # storageClass: "-"
  accessModes:
    - ReadWriteOnce
  size: 1Gi

## ref: https://hub.docker.com/r/erlio/docker-vernemq/
env:
  DOCKER_VERNEMQ_DISCOVERY_KUBERNETES: "1"

volumeMounts:
  - name: data
    mountPath: /var/lib/vernemq

files: {}
